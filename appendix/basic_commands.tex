\chapter{Commander X16 BASIC}

This manual has introduced you to the BASIC language and many of the commands,
operators, and conventions.  However, that is not enough in order to truly
understand how to use BASIC.  This appendix is a reference that aims to provide
a complete documentation for Commander X16 BASIC.  It will provide the rules
(known as \emph{syntax}) of the BASIC language, and concise descriptions of
each BASIC command.\\

To make this information easier to read, it is broken up into the following
sections:\\

\begin{enumerate}

	\item {\bfseries Variables}: describes what variables are, the different
		types of variables, and the allowed variable names.

	\item {\bfseries Operators}: describes arithmetic and logical operators.

	\item {\bfseries Commands}: describes the interactive commands that are
		used to work with programs or perform other tasks that users typically
		type directly into the {\ttfamily READY} prompt.

	\item {\bfseries Statements}: describes the statements that are typically
		used in BASIC programs, but aren't often called directly by users from
		the {\ttfamily READY} prompt.

	\item {\bfseries Functions}: describes the BASIC functions that return
		values, such as calculations and string operations.

\end{enumerate}

\vspace{16pt}

\note{

	Commands and statements are not technically different, and often these
	terms are used interchangeably.  Commands can be used from within BASIC
	programs and statements can be run directly from the {\ttfamily READY}
	prompt.  The reason for different labels is because many commands make
	little sense when used from within BASIC programs.  For example, using the
	{\ttfamily NEW} command inside a BASIC program will cause the program to
	halt execution and be removed from memory!

}

\section{Variables}

Variables are values that have been given names.  Programs use variables for
many purposes, and they are an important part of BASIC programming.
Programmers can \emph{assign} a value to a variable, and then use that value
later in their program by referring to the variable.  For example:\\

\codeblock{
	10 T\$ = "X16"\\
	20 PRINT T\$\\
}

The above BASIC program stores the value {\ttfamily "X16"} in a variable named
{\ttfamily T\$}, and then {\ttfamily PRINT}s the value of {\ttfamily T\$} to
the screen.\\

Variables are similar to memory addresses except for a couple of key
differences.  First, the programmer doesn't have to keep track of where a
variable is stored in the Commander X16's memory.  This job is performed by
BASIC to make the programmer's job easier.  Second, variables have a
\emph{type}.  There are three types of variables in Commander X16 BASIC.  The
three types of variables are: \emph{floating point}, \emph{integer numeric},
and \emph{string (alphanumeric)} variables.\\

\subsection{Floating Point Variables}

\emph{Floating point numeric variables} can have any value from $-10^{38}$ to
$10^{38}$, with up to nine digits of accuracy.  Floating point values can hold
partial values, such as $3.4$, $42.7$, or $0.000025$.  This makes them useful
for a variety of mathematical uses.  Floating point variables can be named with
any single letter, any letter followed by a number, or with two
letters\footnote{There are three variable names that are \emph{reserved} by the
Commander X16 for its own use, and cannot be used for variable names in your
programs.  These names are {\ttfamily ST}, {\ttfamily TI}, {\ttfamily TI\$},
and {\ttfamily DA\$}}.  For example, {\ttfamily A}, {\ttfamily A5}, or
{\ttfamily AB}.\\

To assign a floating point variable, type your chosen name for the variable
followed by an {ttfamily =} and then the value you wish to assign it:\\

\codeblock{
	A = 3.4\\
	A5 = 42.7\\
	AB = 0.000025\\
}

For numbers that are very large or very small, you may wish to use scientific
notation to assign your variables.  The Commander X16 understands scientific
notation by using the letter {\ttfamily E} to separate the coefficient from the
exponent (the base is always assumed to be $10$).  So to assign the value $3.7
\times 10^{-14}$ to a floating point variable named {\ttfamily B2}, you would
type:\\

\codeblock{
	B2 = 3.7E-14\\
}

Not only can you assign floating point variables using scientific notation, but
the Commander X16 will also display values in scientific notation if they
require more than nine digits.\\

\subsection{Integer Variables}

\emph{Integer numeric variables} should be used whenever the number will always
be a whole number, and always be between $-32768$ and $32767$.  These are
numbers like $1$, $5$, or $-127$.  Integer variables take up less space in the
Commander X16's memory, and doing math with integers is faster than with
floating point numbers.  Integer numeric variables follow the same rules as
floating point variables, except they must have a {\ttfamily \%} character at
the end.  For example:\\

\codeblock{
	B\% = 5\\
	C5\% = -11\\
	BC\% = 1261\\
}

\note{

	Sometimes when writing numbers we place a {\ttfamily ,} to separate groups
	of three digits, such as $1,000$ or $8,006,029,545$.  While this makes
	numbers easier for humans to read, it is not something that Commander X16
	understands.  When typing numbers into your programs, you should never use
	a {\ttfamily ,} but instead type the numbers without it.  So the previous
	numbers would be typed as $1000$ and $8006029545$.\\

}

\subsection{String Variables}

\emph{String variables} are used to store characters, such as words, sentences,
or any other symbol that you can type.  A single string variable can store
either a single character, many characters in a row, or even no characters at
all!String variable names follow the same rules as floating point variables,
except they must have a {\ttfamily \$} character at the end.  The value of a
string variable must be enclosed in quotation marks.  For example:\\

\codeblock{
	N\$ = "COMMANDER X16"\\
	B8\$ = "SEVEN"\\
	DC\$ = "THE NEXT STRING HAS NO CHARACTERS IN IT"\\
	EC\$ = ""\\
}

\subsection{Arrays}

\emph{Arrays} are lists of variables that all share the same name.  You can
specify which item, or \emph{element}, in the list you are using by using a
number.  For example, if you have an array of floating point values in a
variable named {\ttfamily AB} you can use the second value in the array by
typing {\ttfamily AB(2)} where you would normally type a variable name or a
value.  You can create an array that holds any of the above types of variables,
but a single a array can only hold one type of variable.  So an array that was
created to hold seven strings can \emph{only} hold string variables, and will
cause an error if you try to assign an integer to one of the elements.\\

Unlike other variables, array variables usually\footnote{see the documentation
of the {\ttfamily DIM} statement for exceptions} need to be \emph{declared}
before using them.  You can declare your array variable with the {\ttfamily
DIM} statement like so:\\

\codeblock{
	DIM A(25)\\
}

This will tell the Commander X16 to reserve enough memory for twenty-five
floating point variables.  You can access these variables by \emph{indexing}
the array variable {\ttfamily A} when using it, like so:\\

\codeblock{
	PRINT A(14)\\
}

The above example prints the value of the fourteenth \emph{element} of
{\ttfamily A} to the screen.\\

Arrays can have more than one \emph{dimension} by declaring them with more than
one index.  For example a two-dimensional array can be useful for storing data
arranged as rows and columns.  Here is how you would declare an array with 24
rows of 32 columns:\\

\codeblock{
	DIM S\%(32,24)\\
}

The above array can store $32 \times 24$ integer values.  You could even
declare arrays with even higher dimensions if you have a need for it.  Be
warned, however, as higher dimensional arrays take up exponentially more memory
so you will quickly run out.\\

\section{Operators}

Commander X16 BASIC uses three different types of \emph{operators}:
\emph{arithmetic} operators, \emph{comparison} operators, and \emph{logical}
operators.

\subsection{Arithmetic Operators}

\emph{Arithmetic operators} are used for mathematical calculations.  Here are
the available arithmetic operators:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{+}&addition\\
	\ttfamily\bfseries{-}&subtraction\\
	\ttfamily\bfseries{*}&multiplication\\
	\ttfamily\bfseries{/}&division\\
	\ttfamily\bfseries{â†‘}&raising to a power (exponentiation)\\
\end{tabular}

\vspace{16pt}

When several operators are used in the same arithmetic expression, there is an
\emph{order} in which the operations execute.  First, any exponentiation
operations execute.  Next, any multiplication or division operations execute.
Finally, any addition or subtraction operations execute.  When there are two or
more operations that execute at the same time, such as a multiplication
followed by a division, the operations execute from left to right.  Consider
the following:\\

\codeblock{
	PRINT 2/4/2\\
}

The above code will execute and print {\ttfamily .25} to the screen instead of
printing {\ttfamily 1}.  This is because {\ttfamily 2/4} executes first to
produce {\ttfamily .5}, and then {\ttfamily .5/2} executes to produce a final
value of {\ttfamily .25}.  If desired, you can force the order of operations by
enclosing calculations inside parentheses.  For example, we could reverse the
order of the operations above by typing:\\

\codeblock{
	PRINT 2/(4/2)\\
}

Now the result is {\ttfamily 1} because {\ttfamily 4/2} is executed first to
produce {\ttfamily 2}, and then {\ttfamily 2/2} executes to produce {\ttfamily
1}.

Using parentheses is a good practice even when not necessary, because it makes
the intention of the calculation obvious when reading the code.  Had we used
them in the original example, it would have made the execution obvious at first
glance:\\

\codeblock{
	PRINT (2/4)/2\\
}

The above code is identical to {\ttfamily 2/4/2}, but is easier to read.

\subsection{Comparison Operators}

\emph{Comparison operators} are useful for determining equalities and
inequalities.  These are used comparing values against each other to determine
if they are the same, not the same, or which is larger.  The comparison
operators are:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{=}&is equal to\\
	\ttfamily\bfseries{<}&is less than\\
	\ttfamily\bfseries{>}&is greater than\\
	\ttfamily\bfseries{<= or =<}&is less than or equal to\\
	\ttfamily\bfseries{>= or =>}&is greater than or equal to\\
	\ttfamily\bfseries{<> or ><}&is not equal to\\
\end{tabular}

\vspace{16pt}

Comparison operators are most often used with {\ttfamily IF...THEN} statements.
For example:\\

\codeblock{
	A = 12\\
	IF A > 10 THEN PRINT "GREATER THAN 10"\\
}

As you can see from the code above, both variables and literal values can be
used with comparison operators.\\

\subsection{Logical Operators}

\emph{Logical operators} are used to join together multiple comparison
statements into a single statement.  There are three logical operators:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{AND}&is true if both the left side and the right side are true\\
	\ttfamily\bfseries{OR}&is true if either the left side or the right side are true\\
	\ttfamily\bfseries{NOT}&is true if the right side is false\\
\end{tabular}

\vspace{16pt}

By using these logical operators, you can write complex conditions for your
programs.  Here's some examples:\\

\codeblock{
	IF A = B AND C = D THEN 100\\
	IF A = B OR NOT (C = D) THEN 100\\
}

Notice how parentheses can be used to explicitly force the order in which
logical conditions are evaluated, just like how they force the order in which
arithmetic is evaluated.\\

\section{Commands}

\emph{Commands} are instructions that you type in order to work with programs
on the Commander X16 or perform other user tasks.  Commands tell the Commander
X16 to do things, such as {\ttfamily LIST} the contents of the SD card,
{\ttfamily LOAD} a program from the SD card, or {\ttfamily RUN} the currently
loaded program.  This section contains a description of each command in
alhabetical order.\\

\subsection{BANNER}

The {\ttfamily BANNER} command displays the Commander X16 logo and boot text,
like is automatically displayed upon boot.

\subsection{BOOT}

The {\ttfamily BOOT} command loads and runs a PRG file named {\ttfamily
AUTOBOOT.X16} from device \#8 (the SD card reader). If the file is not found,
nothing is done and no error is printed.\\

\subsection{CLR}

The {\ttfamily CLR} command clears the BASIC variables from memory.  This
includes variables that were assigned values while running BASIC programs as
well as any BASIC assignments that were called from the {\ttfamily READY}
prompt directly.  Variables cleared with {\ttfamily CLR} cannot be restored
with the {\ttfamily OLD} command.

The {\ttfamily CLR} command runs automatically whenever the {\ttfamily RUN}
command is called, so that each run of a program starts with a cleared
variables state.  {\ttfamily CLR} is \emph{not} called when the {\ttfamily
CONT} command is run, so that a prgram can continue where it left off with the
variable state in tact.\\

\subsection{CLS}

The {\ttfamily CLS} command clears the screen. This has the same effect as
typing {\ttfamily PRINT CHR\$(147);} or typing
\keybackgroundcolor{gray}\keytextcolor{black}\widekey{shift}+\doublekey{clr\\home}.
This command is useful when programs and commands have cluttered up the screen,
and is also useful in BASIC programs to {\ttfamily PRINT}ing to an empty
screen.\\

\subsection{CONT (continue)}

When a program has been stopped by either using the
\keybackgroundcolor{gray}\doublekey{RUN\\STOP} key, a {\ttfamily STOP}
statement, or an {\ttfamily END} statement within the program, it can be
restarted by using the {\ttfamily CONT} command.  The {\ttfamily CONT} command
will continue executing the loaded program at the exact place from which it
left off, with all the variables intact.\\

The {\ttfamily CONT} command will not always work, however.  If you make any
modifications to your program while it is stopped, the {\ttfamily CONT} command
will fail and display a {\ttfamily CAN'T CONTINUE ERROR}.  This is true even if
you {\ttfamily LIST} the program and hit \widekey{RETURN} while the cursor is
on a line of the program...even if you didn't make any modifications.  To the
X16, this is still considered a change to the program, so the only way to run
it again is to start at the beginning of the program by using the {\ttfamily
RUN} command.\\

\subsection{DOS}

This command works with the command/status channel or the directory of a
Commodore DOS device and has different functionality depending on the type of
argument.\\

\begin{itemize}

	\item Without an argument, DOS prints the status string of the current device.

	\item With a string argument of {\ttfamily "8"} or {\ttfamily "9"}, it
		switches the current device to the given number.

	\item With an argument starting with {\ttfamily "\$"}, it shows the
		directory of the device.

	\item Any other argument will be sent as a DOS command.

\end{itemize}

\vspace{16pt}

Examples:\\

\codeblock{
	DOS"\$"          : REM SHOWS DIRECTORY\\
	DOS"S:BAD\_FILE" : REM DELETES "BAD\_FILE"\\
	DOS             : REM PRINTS DOS STATUS\\
}

\subsection{HELP}

The {\ttfamily HELP} command displays a brief summary of the current ROM build,
VERA version, and PS/2 microcontroller code version.  It also displays some
URLs for documentation and community support.  All of this information could be
useful in troubleshooting issues the Commander X16.\\


\subsection{KEYMAP}

The {\ttfamily KEYMAP} command sets the current keyboard layout. It can be put
into an {\ttfamily AUTOBOOT.X16} file to always set the keyboard layout on
boot.\\

Example:\\

\codeblock{
	10 REM PROGRAM TO SET LAYOUT TO SWEDISH/SWEDEN\\
	20 KEYMAP "SV-SE"\\
	SAVE"AUTOBOOT.X16"  :REM SAVE AS AUTOBOOT FILE\\
}

\subsection{LIST}

The {\ttfamily LIST} command will print the currently loaded BASIC program to
the screen, either in its entirety or only the parts specified by the user.
When {\ttfamily LIST} is used without any numbers typed after it (known as
\emph{arguments}), you will see a complete listing of the program on your
screen.  If the program scrolls off the screen, and you are unable to see the
part that you want, you have a couple of options.  First, you can use the
\widekey{CTRL} key to slow down how fast lines are printed to the screen.  The
part you wish to see will still scroll off eventually, but you will be given a
much longer time to look at it.  Second, you can use the {\ttfamily LIST}
command with arguments that will limit the listing to only the line or lines
that you wish to see.  When you follow the {\ttfamily LIST} command with a
single number, the X16 will list only that line number (if it exists).  If you
follow {\ttfamily LIST} with two line numbers separated by a dash, the X16 will
list all the lines from the first number to the second (including both line
numbers).  If you follow {\ttfamily LIST} with a dash followed by a single
number, it lists from the beginning of the program up to and including the line
number.  Finally, if you follow {\ttfamily LIST} with a number followed by a
dash, it lists from the line number until the end of the program.\\

Examples:\\

\begin{tabular}{l p{0.8\linewidth}}
	{\ttfamily\bfseries LIST}&Shows entire program.\\\\
	{\ttfamily\bfseries LIST 10-}&Shows only from line 10 through the end.\\\\
	{\ttfamily\bfseries LIST 10}&Shows only line 10.\\\\
	{\ttfamily\bfseries LIST -10}&Shows from the beginning through line 10.\\\\
	{\ttfamily\bfseries LIST 10-20}&Shows lines from 10 through 20.\\\\
\end{tabular}

\vspace{16pt}

\subsection{LOAD}

The {\ttfamily LOAD} command is used when you want to use a program that is
stored on the Commander X16's SD card\footnote{the {\ttfamily LOAD} command can
also be used with other devices, but only the SD card reader ships with the
Commander X16}.  Typing {\ttfamily LOAD} and hitting \widekey{Return} will find
the first program on the SD card\footnote{The SD card uses the FAT32 disk
format, so it's complicated what makes a file considered to be the "first".  It
is safer to specify the name of the file when possible} and bring it into
memory to be {\ttfamily RUN}, {\ttfamily LIST}ed, or edited.  You can also type
{\ttfamily LOAD} followed by a name of a file in quotes({\ttfamily ""}) to
specify which file to load into memory.  The file name argument may be followed
by a comma and a numeric value which specifies a device number.  If no number
is given, the X16 uses device \#8, which is the SD card reader.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries LOAD}&Loads the first program on the SD card into
	memory.\\\\

	{\ttfamily\bfseries LOAD "HELLO.PRG"}&Loads a program named {\ttfamily
	HELLO.PRG} from the SD card into memory.\\\\

	{\ttfamily\bfseries LOAD A\$}&Loads a program whose name is stored in the
	string variable {\ttfamily A\$} from the SD card into memory.\\\\

	{\ttfamily\bfseries LOAD "HELLO.PRG",9}&Loads a program named {\ttfamily
	HELLO.PRG} from the drive configured as device \#9.\\\\

\end{tabular}

\vspace{16pt}

There are also special file names that can be loaded that perform specific
tasks when used with {\ttfamily LOAD}:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries LOAD "*",8}&Loads the first program on device \#8 into
	memory.\\\\

	{\ttfamily\bfseries LOAD "\$"}&Loads a directory listing of the SD card
	into memory which can be displayed with {\ttfamily LIST}.\\\\

\end{tabular}

\vspace{16pt}

The {\ttfamily LOAD} command can be used with a BASIC program to load and
{\ttfamily RUN} another program.\\

\subsection{MON}

The {\ttfamily MON} command causes the Commander X16 to enter the machine
language monitor.\\

\subsection{NEW} 

The {\ttfamily NEW} command marks the current program and its variables as
erased, but leaves them in memory.  This behavior is so that both the program
and its variables can be restored with the {\ttfamily OLD} command.  The effect
is that the Commander X16 is ready for a new program.\\

\subsection{OLD}

 The {\ttfamily OLD} command recovers the BASIC program in RAM that has been
 previously marked erased either by using the {\ttfamily NEW} command, by
 pressing the reset button on the case, or by pressing the
 \keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{del}
 key combination on the keyboard.\\

\subsection{REBOOT}

The {\ttfamily REBOOT} command performs a software reset of the system by
calling the ROM reset vector.  This performs all the boot routines in the
system ROM, but does not force the hardware to reset.  The {\ttfamily REBOOT}
command {\em does not} clear memory, but {\em does} clear any BASIC program
that is loaded.  Because it is still in memory, however, a previously loaded
BASIC program can be re-loaded by using the {\ttfamily OLD} command after a
reboot:\\

\screenbox{2.75in}{2in}{
	NEW\\
	10 PRINT "EXISTING PROGRAM"\\
	REBOOT\\
}
\screenbox{2.75in}{2in}{
	**** X16 BASIC ****\\
	512k HIGH RAM\\
	38655 BASIC BYTES FREE\\
	READY.\\
	OLD\\
	LIST\\
	10 PRINT "EXISTING PROGRAM"\\
	READY.\\
	\cursor
}

\subsection{REN}

The {\ttfamily REN} command renumbers a BASIC program while updating the line
number arguments of {\ttfamily GOSUB}, {\ttfamily GOTO}, {\ttfamily RESTORE},
{\ttfamily RUN}, and {\ttfamily THEN}.  The {\ttfamily REN} command takes three
optional arguments:\\

\begin{itemize}

	\item The line number of the first line after renumbering, default: {\ttfamily 10}

	\item The value of the increment of subsequent lines, default: {\ttfamily 10}

	\item The ealiest old line to start renumbering, default: {\ttfamily 0}

\end{itemize}

\vspace{16pt}

Example:\\

\codeblock{
	10 PRINT "HELLO"\\
	15 PRINT "CLEAN"\\
	20 PRINT "THIS"\\
	40 PRINT "UP"\\
	REN 100,5\\\\
	LIST\\
	100 PRINT "HELLO"\\
	105 PRINT "CLEAN"\\
	110 PRINT "THIS"\\
	115 PRINT "UP"\\
}

\subsection{RESET}

The {\ttfamily RESET} command performs a full system reset, but does not clear
memory.  This means that a BASIC program and its variables can be restored
after a {\ttfamily RESET} by using the {\ttfamily OLD} command.  Unlike the
{\ttfamily REBOOT} command, this triggers the Commander X16's hardware reset
line, which may be used by expansion ports to reset custom hardware.\\

\note{

	There are multiple ways to reset a Commander X16, and each produces a
	slightly different result.\\

	The first is by using the
	\keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{restore}
	key combination.  This halts the execution of any program, clears the
	screen, and returns the user to the {\ttfamily READY} prompt.  It does not
	mark a program or its variables as erased, and so a program can be
	{\ttfamily RUN} again or {\ttfamily CONT}inued if desired.  This is
	equivalent to pressing the NMI button on the motherboard.\\

	The second is by using the {\ttfamily REBOOT} command.  This calls the
	initial boot up routines, clears any BASIC program, but does not clear the
	memory.  A previously loaded BASIC program can be restored with the
	{\ttfamily OLD} command.\\

	The third is by using the {\ttfamily RESET} command.  This is equivalent to
	pressing the reset button on the motherboard or pressing the
	\keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{del}
	key combination.\\

	The fourth is a cold reboot, where the power to the Commander X16 is lost
	and then restored.  This causes the current program and its variables to be
	completely lost and they cannot be restored with the {\ttfamily OLD}
	command.  }

\subsection{RUN}

The {\ttfamily RUN} command executes the program currently loaded into memory.
This program could have been typed in, or it could have been loaded from the SD
card with the {\ttfamily LOAD} command.  When called, the {\ttfamily RUN}
command will clear the BASIC variables (just like calling the {\ttfamily CLR}
command) and begin running the program.  When no number follows the {\ttfamily
RUN} command, the program will start executing from the lowest line number in
the program.  Otherwise, {\ttfamily RUN} will start executing at the given line
number, or the next lowest line number in the program.\\

Examples:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries RUN}&Starts program from lowest line number.\\\\

	{\ttfamily\bfseries RUN 50}&Starts program at line 50.\\\\

	{\ttfamily\bfseries RUN A}&UNDEFINED ERROR ({\ttfamily RUN} cannot be used
	with a variable to specify a line number).\\\\

\end{tabular}

\subsection{SAVE}

The {\ttfamily SAVE} command will store the the current program in memory to
the SD card or another storage device.  The {\ttfamily SAVE} command should be
followed either by a file name in quotation marks, or a string variable that
contains the desired file name\footnote{calling the {\ttfamily SAVE} command
without any arguments is technically allowed, but doesn't do anything.  On the
Commodore VIC-20 and Commodore 64 this was useful for saving the current
program to the current position of a tape drive with no name, but the Commander
X16's default device is an SD card reader where this concept makes no sense.
For historical reasons, the Commander X16 won't display an error if you run
{\ttfamily SAVE} with no arguments, but it also won't do anything}.  The file
name argument can be followed by a comma and a number or numeric variable.
This number tells the Commander X16 which device to store the file on.  Device
number 8 is the SD card drive and is used if no number is given.\\

If a tape dirve is used with the Commander X16, then a second numeric argument
of either {\ttfamily 0} or {\ttfamily 1} can be specified after the device
number.  If this second is a {\ttfamily 1}, an {\ttfamily END-OF-TAPE} marker
will be written after the program.  If you are attempting to {\ttfamily LOAD} a
program off a tape drive and this marker is read before finding the desired
file, a {\ttfamily FILE NOT FOUND ERROR} will be displayed.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries SAVE "HELLO.PRG"}&Saves the program in memory to a file
	on the SD card with the name {\ttfamily HELLO.PRG}.\\\\

	{\ttfamily\bfseries SAVE A\$}&Saves the program in memory to a file on the
	SD card the name contained in the variable{\ttfamily A\$}.\\\\

	{\ttfamily\bfseries SAVE "HELLO.PRG",1}&Saves the program in memory to a
	file on the drive configured as device \#1 with the name {\ttfamily
	HELLO.PRG}.\\\\

	{\ttfamily\bfseries SAVE "HELLO.PRG",1,1}&Saves the program in memory to a
	file on the drive configured as device \#1 with the name {\ttfamily
	HELLO.PRG} and writes an {\ttfamily END-OF-TAPE} marker after it.\\\\

\end{tabular}

\subsection{VERIFY}

The {\ttfamily VERIFY} command will compare the program in memory to a program
on the SD card or other storage device.  If the programs are the same, the
{\ttfamily VERIFY} command will display an {\ttfamily OK} message, and if they
differ it will display a {\ttfamily VERIFY ERROR} message.  This command helps
to ensure that a program is safely stored to the SD card or other storage
device before the user erases it from memory\footnote{this was far more useful
in the era or tape drives and floppy disks than it is on the Commander X16}.
When {\ttfamily VERIFY} is called without any arguments, it checks the program
in memory against the first file on the SD card\footnote{this is not
particularly useful, but is included behavior for historical reasons}.  When
called followed by a file name in quotation marks or a string variable
containing a file name, it compares the program in memory against the given
file.  Just like the {\ttfamily LOAD} and {\ttfamily SAVE} commands, the
{\ttfamily VERIFY} command can take a numeric second argument as a device
number.\\

% easter egg hidden here as a tribute to a VIC-20 User's Guide printing error
% https://cdn.discordapp.com/attachments/629903630916648962/1075543304680263710/20230215_162450.jpg
The {\ttfamily VERIFY} command can also be used if a tape drive is connected to
the Commander X16 as a storage device.  By {\ttfamily VERIFY}ing the last
program on the taÃ¾e, the position of the tape can be advanced to a safe section
to write over.  When {\ttfamily VERIFY} is complete, whether verification
succeeds or fails, the tape will be positioned at the next available space.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries VERIFY}&Checks the first program on the SD card.\\\\

	{\ttfamily\bfseries VERIFY A\$}&Checks the program with name in variable
	{\ttfamily A\$}.\\\\

	{\ttfamily\bfseries VERIFY "HELLO.PRG",1}&Checks the program on the drive
	configured as device \#1 with the name {\ttfamily HELLO.PRG}.\\\\

\end{tabular}

\section{Statements}

\emph{Statements} are the instructions used in BASIC on numbered lines of
programs.  They are used to define what it is that your program does.\\

\subsection{BANK}

The {\ttfamily BANK} statement sets which bank will be used when other commands
and statements interpret addresses in the \$A000 - \$FFFF range.  Because all
addresses from \$A000 and above are either banked "high" RAM or banked ROM,
certain commands need to know \emph{which} bank is being referred to.
Specifically, {\ttfamily SYS}, {\ttfamily POKE}, and {\ttfamily PEEK} all need
to know which bank to use when an address is given in the banked range.  The
{\ttfamily BANK} statement sets the bank for both banked RAM\footnote{RAM in
bank 0 is reserved for use by the KERNAL, so it is unwise to write values into
there} and banked ROM, although setting the banked ROM is optional.  The first
argument is used to set the RAM bank, and the optional second argument sets the
ROM bank.  To set a bank, call the {\ttfamily BANK} statement followed by a
numeric value from 0 through 255.\\

For example, to write some data into "high" RAM in bank 1:\\

\codeblock{
	10 BANK 1\\
	20 POKE \$A000,42\\
}

Then the bank can be switched, and the same address can be used to store more
data, without overwriting the data in bank 1:\\

\codeblock{
	30 BANK 2\\
	40 POKE \$A000,23\\
	50 BANK 1				REM SWITCH BACK TO BANK 1\\
	60 PRINT PEEK(\$A000)	REM PRINTS 42, NOT 23\\
}

The {\ttfamily BANK} statement also has some use as a command run from the
{\ttfamily READY} prompt.  It can be used to run programs that are shipped with
the Commander X16 in banked ROM.  For example, the CodeX16 Interactive Assembly
Environment in ROM bank 7 can by run by typing the following at the {\ttfamily
READY} prompt:\\

\codeblock{
	BANK 1,7\\
	SYS \$C000\\
}

\subsection{BINPUT\#}

 The {\ttfamily BINPUT\#} statement reads a block of data from an open file and
 stores the data into a string variable.  The {\ttfamily BINPUT\#} statement
 takes 3 arguments; the device number, the string variable to store the data
 into, and the number of bytes to read from the file.  If there are fewer bytes
 to be read than the specified number of bytes has been read, only the bytes
 available will be stored in the string variable.  If the end of the file is
 reached, the special variable {\ttfamily ST} will have its bit 6 set to
 {\ttfamily 1}.  This means {\ttfamily ST AND 64} will equal {\ttfamily TRUE}
 when {\ttfamily BINPUT\#} reads all the way to or past the end of the file.\\

 Example:\\

 \codeblock{

	 10 OPEN 8,8,8,"FILE.BIN,S,R"\\
	 20 BINPUT\# 8,A\$,5\\
	 30 PRINT "I GOT";LEN(A\$);"BYTES: ";A\$\\
	 40 IF ST AND 64 THEN 60 REM END OF FILE\\
	 50 GOTO 20\\
	 60 CLOSE 8\\
	 70 PRINT "FINISHED READING"\\

 }

\subsection{BLOAD}

The {\ttfamily BLOAD} statement loads a headerless\footnote{typically on
Commodore computers as well as the X16, files are expected to contain a
two-byte header that indicates an address where they are to be loaded into
memory.  A "headerless" file will not have those two bytes} file from a device
into banked RAM.  If the file is too large to fit within a bank, the {\ttfamily
BLOAD} statement will automatically continue writing the file to the next bank.
This allows file resources larger than 8 kilobytes to be used without the need
to break them up into smaller files.  This is useful for loading resources for
games and applications into "high" RAM that programs can then access during
execution.\\

Examples:\\

\begin{tabular}{l p{0.4\linewidth}}

	{\ttfamily\bfseries BLOAD "MYFILE.BIN",8,1,\$A000}&Loads a file named
	"MYFILE.BIN" from device 8 starting in bank 1 at \$A000.\\\\

	{\ttfamily\bfseries BLOAD "WHO.PCX",8,10,\$B000}&Loads a file named
	"WHO.PCX" from device 8 starting in bank 10 at \$B000.\\\\

\end{tabular}

\subsection{BVERIFY}

The {\ttfamily BVERIFY} statement compares a headerless file on the SD card or
other storage device to the contents of banked RAM.  As arguments, the
{\ttfamily BVERIFY} statement takes the name of the file, the device number,
the bank number, and the starting address within the bank.  If the file in
question extends past the end of the bank, the {\ttfamily BVERIFY} statement
will automatically continue checking on the file on the next bank, resetting
the address to {\ttfamily \$A000} as it changes the bank.  This allows it to be
used to verify files that are too large to fit inside a single bank of "high"
RAM.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries BVERIFY "MYFILE.BIN",8,1,\$A000}&Compares a file named
	"MYFILE.BIN" from device 8 against the RAM in bank 1 starting at
	\$A000.\\\\

	{\ttfamily\bfseries BVERIFY "WHO.PCX",8,10,\$B000}&Compares a file named
	"WHO.PCX" from device 8 against the RAM in bank 10 starting at \$B000.\\\\

\end{tabular}

\subsection{BVLOAD}

The {\ttfamily BVLOAD} statement loads a headerless file directly into the
VERA's VRAM.  For arguments, the {\ttfamily BVLOAD} statement takes the file's
name, the device number where the file is stored, the bank of VRAM on the VERA
(either {\ttfamily 0} or {\ttfamily 1}), and the address within the bank in
which to load.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries BVLOAD "MYFILE.BIN",8,0,\$4000}&Loads a file named
	"MYFILE.BIN" from device 8 into VRAM at address \$04000.\\\\

	{\ttfamily\bfseries BVLOAD "MYFONT.BIN",8,1,\$F000}&Loads a file named
	"MYFONT.BIN" from device 8 into VRAM at address \$1F000.\\\\

\end{tabular}

\subsection{CHAR}

The {\ttfamily CHAR} statement draws text to the screen at a given X,Y
coordinate and a given color.  The {\ttfamily CHAR} statement is only available
in graphics mode, and draws the text to the bitmap graphics layer instead of
the text layer.  Like other graphics mode statements, the {\ttfamily CHAR}
statement can draw in all 256 available colors.\\

\codeblock{

	10 SCREEN \$80\\
	20 CHAR 120,100,14,"COMMANDER"\\
	30 CHAR 180,100,2,"X16"\\
}

\subsection{CLOSE}

The {\ttfamily CLOSE} statement completes and closes any files used by
{\ttfamily OPEN} statements.  The {\ttfamily CLOSE} statement takes a single
argument that is the file number to be closed.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries CLOSE 0}&Close file 0\\\\

	{\ttfamily\bfseries CLOSE 4}&Close file 4\\\\

\end{tabular}

\subsection{CMD}

The {\ttfamily CMD} statement is used to send output that would normally go to
the screen to some other device instead.  The other device could be a file on
the SD card, a file on a disk or tape drive, a printer, a modem, or any other
device supported by the Commander X16.  The device must first be opened with
the {\ttfamily OPEN} statement followed by a numerical value that will be used
to reference the file or device.\\

Example:\\

\begin{tabular}{l p{0.45\linewidth}}

	{\ttfamily\bfseries OPEN 1,8,8,"NEWFILE,S,W"}&OPEN a file named {\ttfamily NEWFIL} on the SD card\\\\

	{\ttfamily\bfseries CMD 1}& All normal output now goes to a file named {\ttfamily NEWFILE}\\\\

	{\ttfamily\bfseries LIST}&The {\ttfamily LIST}ing goes to the file, not the screen -- even the word {\ttfamily LIST}\\\\

	{\ttfamily\bfseries PRINT\# 1}&Direct the output back to the screen before closing the device\\\\

	{\ttfamily\bfseries CLOSE 1}&Close file 1\\\\
	

\end{tabular}

If a BASIC error occurs the data ouput is switched back to the screen, with the
side effect that space characters will be send to the logical file of the
selected device.  This is why the {\ttfamily PRINT\#} statement should be used
prior to closing the device.\\

\subsection{COLOR}

The {\ttfamily COLOR} statement sets the text mode foreground color, and
optionally the background color.  It takes either one or two arguments, both
are integers from 0 through 15.  The first argument sets the color of the text,
and the optional second argument sets the background color.  The numbers given
correspond to the first 16 colors of the VERA's palette\footnote{If the VERA's
palette has been modified, then the modified colors are used.  The {\ttfamily
COLOR} statement will not restore the default VERA palette}.\\

Examples:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries COLOR 2}&Set the text color to red.\\\\

	{\ttfamily\bfseries COLOR 5,0}&Set the text color to green and the
	background color to black.\\\\

\end{tabular}

The {\ttfamily COLOR} statement only effects areas of the screen where new text
is placed, and will not change existing characters.  This makes it convenient
to use in programs for drawing diagrams and images with PETSCII characters,
since you can change both foreground and background colors for each individual
charater.\\

\subsection{DATA}

The {\ttfamily DATA} statement creates a data section of a BASIC program from
which the {\ttfamily READ} statement will read from.  The {\ttfamily DATA}
statement is followed by a comma-separated list of values.  These values can be
integers, floating point numbers, or strings\footnote{String values can be
specified with or without quotation marks, unless they contain a space, comma,
or colon.  Despite this flexibility, it is best practice to always use
quotation marks for string data}.  It is important to use the correct variable
type when {\ttfamily READ}ing these values, otherwise a {\ttfamily TYPE
MISMATCH} error can occur.  If two commas have nothing between them, the value
will be interpreted as a {\ttfamily 0} for a number or an empty string.\\

Multiple {\ttfamily DATA} statements can be used in a program, and when one has
been completely read by enough {\ttfamily READ} statements, the next {\ttfamily
READ} statement will read from the next {\ttfamily DATA} statement.  All
{\ttfamily READ} statements in a program can be thought of as a single
contiguous block of data, even if the statements are not grouped together in
the program.\\

Examples:\\

\codeblock{
	10 READ A\\
	20 READ B\%\\
	30 READ C\$\\
	40 PRINT A, B\%,C\$\\
	50 DATA 34.2,42\\
	60 DATA "COMMANDER X16"\\
}

{\ttfamily DATA} statements do not need to be executed, so they can slow down a
program if placed before code does need to execute.  Because of this, it is
best to place all {\ttfamily DATA} statements at the end of program.\\

\subsection{DEF}

The {\ttfamily DEF} statement defines a calculation as a named function that
can be called by BASIC later.  This is useful for complex calculations that a
program does multiple times.  The {\ttfamily DEF} statement is followed by the
function name, which must be {\ttfamily FN} followed by one or two other
characters that make up a legal variable name.  This name is followed by a set
of parentheses enclosing a legal numeric variable name.  This is followed by an
equals sign and the formula you want to define, using the variable in the
parentheses like any other variable would be used.\\

Examples:\\

\codeblock{
	10 DEF FNC(R)=2*R*Ï€ REM CIRCUMFERENCE OF  A CIRCLE\\
	20 DEF FNA(R)=Ï€*(Râ†‘2) REM AREA OF  A CIRCLE\\
	30 PRINT "CIRCUMFERENCE:", FNC(10)\\
	40 PRINT "AREA:", FNA(10)\\
}

Only a single variable can be defined as an argument to a function.  The
defined function can be used anywhere a BASIC function can normally be used.\\

\subsection{DIM}

The {\ttfamily DIM} statement is used to \emph{dimension} an array, which means
to allocate enough space for the data the array will hold.  An array variable
needs to be {\ttfamily DIM}'d before using it unless it will only hold eleven
or fewer elements.  In all other cases, the {\ttfamily DIM} statement must be
used.\\

To dimension an array variable, use {\ttfamily DIM} followed by the variable
name.  Then, the size of each dimension of the array should be given, separated
by commas and surrounded by parentheses.  An array can have one or more
dimensions, and each dimension can be as large as needed\footnote{as long as
all the elements fit into memory}.  The total number of elements in an array
can be calculated by multiplying the size of each of the array's dimensions.
The {\ttfamily DIM} statement can dimension multiple arrays at once by
separating each array with a comma.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries DIM A(16)}&An array of 16 numbers.\\\\

	{\ttfamily\bfseries DIM B\$(26),C\%(13)}&An array of 26 strings and an
	array of 13 integers.\\\\

	{\ttfamily\bfseries DIM D(32,4,4)}&A 3-dimensional array of numbers where
	the dimensions are 32, 4, and 4.\\\\

\end{tabular}

Once dimensioned, arrays can be used be used just like other variables, except
that the index into each dimension must be specified:\\

\codeblock{
	10 DIM A\$(3,12)\\
	20 A\$(1,1) = "ONE"\\
	30 A\$(2,6) = "TWO"\\
	40 PRINT A\$(1,1) REM PRINTS "ONE"\\
	50 PRINT A\$(2,6) REM PRINTS "TWO"\\
	60 PRINT A\$(1,6) REM PRINTS NOTHING\\
}

Executing a {\ttfamily DIM} statement on an array more than once will cause an
error.  It is a best practice to keep all the {\ttfamily DIM} statements
towards the beginning of a program.\\

\subsection{END}

The {\ttfamily END} statement will stop a running program just as if it had run
out of lines.  The {\ttfamily CONT} command can then be used to start the
program again, starting from the line after the {\ttfamily END} statement.  In
this way, the {\ttfamily END} statement can be used to "pause" a program and
allow the user to perform other tasks before {\ttfamily CONT}inuing on with the
rest of the program.  For details about the limitations of {\ttfamily
CONT}inuing a program, see the documentation for the {\ttfamily CONT}
command.\\

\subsection{FMCHORD}

The {\ttfamily FMCHORD} statement instructs the FM synthesis chip to begin
playing multiple notes at the same time.  For arguments, the {\ttfamily
FMCHORD} statement accepts a channel and a string.  Because a chord plays
multiple notes at the same time, the channel argument specifies the
\emph{first} channel to use for the chord, but other channels will be used for
subsequent notes.  For example, if you specify a channel argument of {\ttfamily
3} for a chord which plays 4 notes, the {\ttfamily FMCHORD} statement will play
the notes on channels 3, 4, 5, and 6.  It is important to set each of the
channels to use the desired instruments with the {\ttfamily FMINST} statement.
The string argument is used to specify which notes the {\ttfamily FMCHORD}
statement will play.  For more information on specifying notes, see the chapter
on Sound.\\

Example:\\

\codeblock{

	REM PLAY A C MAJOR CHORD ON A PIANO\\
	10 FMINST 0,0:FMINST 1,0:FMINST 2,0\\
	20 FMCHORD 0,"CGE"\\

}

\subsection{FMDRUM}

The {\ttfamily FMDRUM} statement plays a single percussion sound from a set of
percussion instruments.  This set comes from the General MIDI standard
Percussion set\footnote{see the Drum Patch Presets table in the appendix},
which uses numbers from 25 through 87.  The {\ttfamily FMDRUM} statement takes
two arguments.  The first is a channel, and the second is a drum number from
the set.  When this statement executes, it sets the channel to the selected
drum number and plays it.  The channel will retain the drum number set until it
is set again with either {\ttfamily FMINST} or another call to {\ttfamily
FMDRUM}.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries FMDRUM 0,38}&Play an acoustic snare on channel 0.\\\\

	{\ttfamily\bfseries FMDRUM 2,50}&Play a high tom on channel 2.\\\\

	{\ttfamily\bfseries FMDRUM 1,55}&Play a splash cymbal on channel 1.\\\\

\end{tabular}

\subsection{FMFREQ}

The {\ttfamily FMFREQ} statement plays a note on the FM synthesis chip at a
given frequency.  This is an alternative to playing a note with {\ttfamily
FMNOTE}, where instead of specifying a musical note, a frequency in Hertz is
specified.  Like {\ttfamily FMNOTE} and {\ttfamily FMDRUM}, {\ttfamily FMFREQ}
returns immediately and does not wait for a note to finish playing.  If a Hertz
value of {\ttfamily 0} is specified, the channel is immediately silenced.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMFREQ 3,2600}&Plays the instrument on channel 3 at 2,600hz.\\\\

	{\ttfamily\bfseries FMFREQ 0,440}&Equivalent to {\ttfamily FMNOTE 0,\$4A}
	which plays A above middle C on channel 0.\\\\

	{\ttfamily\bfseries FMFREQ 2,0}&Silences channel 2.\\\\

\end{tabular}

\subsection{FMINIT}

The {\ttfamily FMINIT} statement is used to set the FM synthesis chip to a
known state, and takes no arugments.  It performs initializations on the YM2151
sound chip, as well as loading default patches into all 8 channels.  In
addition, it immediately silences the channels.  This last function can be
useful for silencing multiple FM channels at once, without having to call
{\ttfamily FMNOTE} or {\ttfamily FMFREQ} on each one.  The initializations that
the {\ttfamily FMINIT} statement performs are called automatically when the
Commander X16 boots up, so it is not necessary to call {\ttfamily FMINIT}
directly before using other FM statements.  However, it is still a good idea to
call {\ttfamily FMINIT} before using FM statements in a program, especially if
the program relies on the default patches.  There's no guarantee that another
program hasn't modified the state of the FM chip since boot.\\

\subsection{FMINST}

The {\ttfamily FMINST} statement assigns an instrument to a channel.  The first
argument is the channel, and the second argument is a number indicating an
instrument.  The Commander X16's ROM chip comes pre-loaded with 146 FM
instrument patches from the General MIDI Instrument Set.  These instruments and
their numbers can be found in FM Instrument Patch Presets table and the
Extended FM Instrument Patch Presets table in the appendix.\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMINST 0,0}&Set channel 0 to Acoustic Grand Piano.\\\\

	{\ttfamily\bfseries FMINST 3,11}&Set channel 3 to Vibraphone.\\\\

	{\ttfamily\bfseries FMINST 7,127}&Set channel 7 to Gunshot.\\\\

\end{tabular}

\subsection{FMNOTE}

The {\ttfamily FMNOTE} statement plays a single note on the FM synthesis chip.
The first argument is the channel, and the second argument specifies which
note.  The note argument can be any number, but is intended to be specified
with hexadecimal notation.  This is so that the most significant 4 bits (often
called the "high nybble") represent the octave while the least significant 4
bits (the "low nybble") represent the musical note.  The lowest note of any
octave is {\ttfamily\bfseries C}, which is represented with a {\ttfamily 1},
and the highest note of any octave is {\ttfamily\bfseries B}, which is
represented with a {\ttfamily\bfseries C}.  A note of {\ttfamily 0} on any
octave will release the note playing on that channel, and the note values
{\ttfamily\bfseries D}, {\ttfamily\bfseries E}, and {\ttfamily\bfseries F} have
no effect.\\

Although this may seem confusing, it is actually convenient for most uses.
For example to play a "middle C" the note value {\ttfamily \$41} would be used.
The {\ttfamily \$} tells BASIC that the value is hexadecimal, the {\ttfamily 4}
indicates the note is in the 4th octave, and {\ttfamily 1} specifies the note
"C".  Here's a table of which nybble produces which note:\\

\begin{tabular}{|c|c|c|c|c|c|c|c|}
	\hline

	Nybble & \$x0 & \$x1 & \$x2 & \$x3 & \$x4 & \$x5 & \$x6 \\ \hline Note &
	Release & {\ttfamily\bfseries C} & {\ttfamily\bfseries Câ™¯/Dâ™­} &
	{\ttfamily\bfseries D} & {\ttfamily\bfseries Dâ™¯/Eb} & {\ttfamily\bfseries
	E} & {\ttfamily\bfseries F} \\ \hline

	Nybble & \$x7 & \$x8 & \$x9 & \$xA & \$xB & \$xC & \$xD-\$xF \\ \hline Note
	& {\ttfamily\bfseries Fâ™¯/Gâ™­} & {\ttfamily\bfseries G} & {\ttfamily\bfseries
	Gâ™¯/Aâ™­} & {\ttfamily\bfseries A} & {\ttfamily\bfseries Aâ™¯/Bâ™­} &
	{\ttfamily\bfseries B} & no-op \\ \hline

\end{tabular}\\

Negative numbers can also be used to specify notes.  These will be treated as
the same note, except it will merely change an already-playing note rather than
re-triggering it.  This is obviously more useful with some instruments than
with others, but can also be used as a clever way to create sound effects.\\

Examples:\\

\codeblock{

	0 FMINST 1,64 : REM LOAD SOPRANO SAX \\
	10 FMNOTE 1,\$4A : REM PLAYS CONCERT A \\
	20 FOR X=1 TO 5000 : NEXT X : REM DELAYS FOR A BIT \\
	30 FMNOTE 1,0 : REM RELEASES THE NOTE \\
	40 FOR X=1 TO 1000 : NEXT X : REM DELAYS FOR A BIT \\
	50 FMNOTE 1,\$3A : REM PLAYS A IN THE 3RD OCTAVE \\
	60 FOR X=1 TO 2500 : NEXT X : REM SHORT DELAY \\
	70 FMNOTE 1,-\$3B : REM A\# WITHOUT RETRIGGERING \\
	80 FOR X=1 TO 2500 : NEXT X : REM SHORT DELAY \\
	90 FMNOTE 1,0 : REM RELEASES THE NOTE \\

}

\subsection{FMPAN}

The {\ttfamily FMPAN} statement is used to control the stereo output of an FM
channel.  It takes an argument for the channel, and an argument for which
speaker the channel should play from.  The second argument values are as
follows:\\ 

\begin{tabular}{|c|c|}
	\hline
	Left & 1 \\ \hline
	Right & 2 \\ \hline
	Both & 3 \\ \hline
\end{tabular}\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMPAN 0,3}&Set channel 0 to play from both speakers.\\\\

	{\ttfamily\bfseries FMPAN 3,1}&Set channel 3 to play from only the left speaker.\\\\

	{\ttfamily\bfseries FMPAN 7,2}&Set channel 7 to play from only the right speaker.\\\\

\end{tabular}

\subsection{FMPLAY}

The {\ttfamily FMPLAY} statement plays a musical melody on a single channel.
{\ttfamily FMPLAY} takes two arguments; a channel and a string of characters
that tells the FM chip what to play.  This second argument is specified in a
custom macro language\footnote{for a complete guide, see the Macro Language for
Music appendix}, and includes notes, releases, tempos, octaves, rests, and
other musical elements.  For example, the following statement will play a major
scale in the key of {\ttfamily\bfseries C}:\\

\codeblock{
	FMPLAY 0,"CDEFGAB>C"\\
}

Each letter indicates which note to play.  Before playing the final
{\ttfamily\bfseries C} note, the {\ttfamily >} character is used to tell the
channel to move up one octave.  If this character wasn't included, the final
{\ttfamily\bfseries C} would play at the same octave as the first
{\ttfamily\bfseries C}.\\

The characters {\ttfamily +} and {\\ttfamily -} can be placed after a note's
letter to indicate sharps and flats, respectively.  For example, the following
will play a major scale in the key of {\ttfamily\bfseries A}:\\

\codeblock{
	FMPLAY 0,"AB>D-DEF+A-A"\\
}

Because a new octave starts on each {\ttfamily\bfseries C} note, this scale
requires the {\ttfamily >} character to be placed between the
{\ttfamily\bfseries B} and {\ttfamily\bfseries Dâ™­} notes.\\

\tip{Restoring Octaves}{

	You may have noticed that running these {\ttfamily FMPLAY} statements
	multiple times results in them playing in different octaves.  This is
	because the Commander X16 remembers which octave each channel was left in.
	So when using {\ttfamily >} to increase the octave on one {\ttfamily
	FMPLAY} statement, the channel stays in that octave during the next
	{\ttfamily FMPLAY} statement.  This can be solved in a number of ways:\\

	\begin{itemize}

		\item An initial octave can be specified at the beginning of the string
			with the {\ttfamily O} macro

		\item A {\ttfamily <} character can be placed at the end of the string
			to indicate that the channel should move down one octave

		\item The octave can be reset with the {\ttfamily FMINIT} statement.
			Just keep in mind that this resets the octaves of \emph{all}
			channels, as well as silencing them and restoring them to their
			default instruments

			

	\end{itemize}



}

\subsection{FMPOKE}

The {\ttfamily FMPOKE} statement can be used to write values directly to the
registers of the FM sound chip.  To understand what values to write to which
registers, see the appendix on YM2551 Registers.\\

Using {\ttfamily FMPOKE}, it is possible to directly interface with the FM chip
and make it do things that are not possible by using the other FM BASIC
statements.  For example, {\ttfamily FMPOKE} can be used to define a new
instrument patch instead of using one of the predefined patches.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries FMPOKE \$28,\$4A}&Set {\ttfamily KC} to {\ttfamily A4} on channel 0.\\\\

	{\ttfamily\bfseries FMPOKE \$08,\$00}&Release channel 0.\\\\

	{\ttfamily\bfseries FMPOKE \$08,\$78}&Start note playback on channel 0 with all operators.\\\\

\end{tabular}

\subsection{FMVIB}

The {\ttfamily FMVIB} statement sets the speed of the FM chip's LFO, as well as
the depth of the amplitude modulation or phase modulation.  The first argument
sets the speed from 0-255, and the second argument sets the depth from 0-127.
The {\ttfamily FMVIB} statement applies to all channels, and only to instrument
patches that use either amplitude or phase modulation (see the Instrument Patch
Presets table in the appendix).\\

Example:\\

\codeblock{
	10 FMINST 0,11 : REM SET CHANNEL 0 TO VIBRAPHONE\\
	20 FMVIB 200,60 : REM SET VIBRATO\\
	30 FMNOTE 0,\$4A : REM PLAY CONCERT A\\
}

\subsection{FMVOL}

The {\ttfamily FMVOL} statement sets a channel's volume.  The first argument is
the channel, and the second argument is a value from 0 through 63.  The volume
is maintained for the channel, even if the instrument patch is switched.  Only
another {\ttfamily FMVOL} statement or an {\ttfamily FMINIT} statement will
cause the volume of a channel to change.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMVOL 0,63}&Set channel 0 to full volume.\\\\

	{\ttfamily\bfseries FMVOL 1,31}&Set channel 1 to half volume.\\\\

	{\ttfamily\bfseries FMVOL 2,0}&Set channel 2 to no volume, silencing it.\\\\

\end{tabular}

\subsection{FOR}

The {\ttfamily FOR} statement is used with the {\ttfamily TO} statement, the
{\ttfamily NEXT} statement, and sometimes the {\ttfamily STEP} statement to
create a section of a program that executes a specific number of times.  This
repeating section of a program is commonly called a "for-loop".\\

The format of a for-loop is as follows:\\

\codeblock{
	FOR <loop variable> = <start> TO <end>\\
	<code to execute multiple times ...>\\
	NEXT <loop variable>\\
}

In the above example, {\ttfamily <loop variable>} can be any legal name for a
floating point variable.  Both {\ttfamily <start>} and {\ttfamily <end>} are
floating point values, and both variables and constants are allowed.\\

For example, here is a for-loop that prints the numbers {\ttfamily 1} through
{\ttfamily 10} to the screen:\\

\codeblock{
	FOR X = 1 TO 10\\
	PRINT X\\
	NEXT X\\
}

\subsection{FRAME}

The {\ttfamily FRAME} statement draws a rectangle frame in graphics mode in a
given color.  The first two arguments are the x and y coordinates for the upper
left corner of the frame.  The third and fourth arguments are the x and y
coordinates for the lower right corder of the frame.  The fifth argument is a
number from 0-255 that specifies the color from the current palette.\\

Example:\\

\codeblock{
	10 SCREEN \$80\\
	20 FRAME 10,10,310,230,2\\
}

The {\ttfamily FRAME} statement is similar to the {\ttfamily RECT} statment,
except that {\ttfamily FRAME} does not fill in the rectangle.

\subsection{GET}

The {\ttfamily GET} statement gets data from the keyboard one character at a
time.  The {\ttfamily GET} statement will read a single character from the
keyboard cache and place it into a variable provided as an argument.  Any
character can be placed into a string variable, but only numeric characters can
be placed into integer or floating point variables.  When the keyboard cache is
empty (no keys are currently pressed), a default value is placed into the
specified variable.  For string variables the default value will be the empty
string ({\ttfamily ""}), but for floating point and integer variables the
default value will be {\ttfamily 0.0} and {\ttfamily 0}, respectively.\\

If there are more than one characters currently in the keyboard cache,
then a single call to {\ttfamily GET} can retrieve them all by specifying
multiple variables as arguments.\\

Examples:\\

\begin{tabular}{l p{0.85\linewidth}}

	{\ttfamily\bfseries GET A\$} & Read a single character from the keyboard into {\ttfamily A\$}\\\\

	{\ttfamily\bfseries GET I\$} & Read a single character from the keyboard
	into {\ttfamily I\%}, and cause an error if that character is not
	numeric\\\\

	{\ttfamily\bfseries GET F} & Read a single character from the keyboard into
	{\ttfamily F}, and cause an error if that character is not numeric\\\\

	{\ttfamily\bfseries GET A\$,B\$} & Read two characters from the keyboard
	cache into {\ttfamily A\$} and {\ttfamily B\$}\\\\

\end{tabular}

\vspace{16pt}

A common use for the {\ttfamily GET} statement is to pause a program in a loop until the user presses a key:\\

\codeblock{
	10 PRINT "PRESS ANY KEY TO CONTINUE"\\
	20 GET A\$:IF A\$="" GOTO 20\\
	30 PRINT "THANK YOU FOR PRESSING A KEY!"\\
}

\subsection{GET\#}

The {\ttfamily GET\#} statement reads data from a specified logical file one
character at a time.  It is identical to the {\ttfamily GET} statement except
that it requires a first argument specifies a logical file identifier.  The
logical file must first be opened with the {\ttfamily OPEN} statement.  The
remaining arguments work just the same as with the {\ttfamily GET} statement.\\

Example:\\

\codeblock{
	10 OPEN 1,1,0,"FILENAME"  REM OPEN TAPE DRIVE FILE\\
	20 GET\#1,A\$  REM READ A CHARACTER FROM THE TAPE\\
}

\note{

	It is a popular convention when using statements and commands that end in
	{\ttfamily \#} to place the device number directly after the command with
	no space.  So instead of {\ttfamily GET\# 1,A\$} this example shows
	{\ttfamily GET\#1,A\$}.

}


\subsection{GOSUB}

The {\ttfamily GOSUB} statement transfers program execution to a specified line
and remembers which line which called {\ttfamily GOSUB}.  This is different
than the {\ttfamily GOTO} statement which transfers program execution, but does
not have a way to return control to the line which called {\ttfamily GOTO}.
The {\ttfamily GOSUB} statement allows for the creation of {\em subroutines}
(often called {\em functions}, {\em procedures}, or {\em methods} in other
programming languages).  After {\ttfamily GOSUB} is called and program
execution has been transfered to a new line, the next time a {\ttfamily RETURN}
statement is executed it will transfer program execution back to the line
directly {\em after} the {\ttfamily GOSUB} statement.\\

Example:\\

\codeblock{
	10 PRINT "FIRST"\\
	20 GOSUB 50\\
	30 PRINT "THIRD"\\
	40 END\\
	50 PRINT "SECOND"\\
	60 RETURN\\
}

The above program will print {\ttfamily FIRST}, {\ttfamily SECOND}, and
{\ttfamily THRID} in order.  This is because the {\ttfamily GOSUB} statement on
line 20 transfers execution to line 50, and then the {\ttfamily RETURN}
statement on line 60 then transfers execution back to line 30, which is the
line {\em after} the {\ttfamily GOSUB} statement was called.\\

\tip{Nesting Subroutines}{

	It is possible to "nest" subroutines created by {\ttfamily GOSUB} such that
	a subroutine calls a subroutine which calls a subroutine...and so on!  This
	can be useful for creating BASIC programs with complex logic.\\

}

\subsection{GOTO}

The {\ttfamily GOTO} statement transfers program execution to the line
specified.  Unlike the {\ttfamily GOSUB} statement, the {\ttfamily GOTO}
statement does {\em not} remember where it was called from, and therefore the
{\ttfamily RETURN} statement will {\em not} return program execution.\\

Example:\\

\codeblock{
	10 PRINT "THIS WILL PRINT"\\
	20 GOTO 40\\
	30 PRINT "THIS WILL NOT PRINT"\\
	40 PRINT "THIS WILL ALSO PRINT"\\
}

\subsection{IF}

The {\ttfamily IF} statement is how decisions are made in BASIC.  The
{\ttfamily IF} statement is followed by an expression that either evaluates to
{\ttfamily TRUE} or {\ttfamily FALSE}, and the next statement executed is
dependent on the outcome.  The expression is followed by either a {\ttfamily
THEN} statement or a {\ttfamily GOTO} statement.  A {\ttfamily THEN} statement
is followed by another statement or a line number, and a {\ttfamily GOTO
statement} is followed by a line number.  If the expression evaluates to
{\ttfamily TRUE}, then the statement following the {\ttfamily THEN} statement
is executed.  If a line number is used, either with a {\ttfamily THEN} or
{\ttfamily GOTO} statement, then the program will jump to that line number.
When the expression evaluates to {\ttfamily FALSE}, then the line after the
{\ttfamily IF} statement is executed.\\

Expressions can be either a variable or a formula.  In both cases a zero is
considered {\ttfamily FALSE}, and any non-zero value is considered {\ttfamily
TRUE}.  In most cases, the statement will be constructed from variables,
comparison operators, and logical operators.  See the section on operators for
more details.\\

Example:\\

\codeblock{

	10 A=10\\
	20 IF A=9 THEN 40\\
	30 IF A=10 THEN 60\\
	40 PRINT "THIS SHOULD NOT PRINT"\\
	50 END\\
	60 PRINT "THIS SHOULD PRINT"\\

}

\subsection{INPUT}

The {\ttfamily INPUT} statement asks the user of a BASIC program for data to
store in a variable.  The program will print an optional prompt (much like the
{\ttfamily PRINT} statement), print a question mark (?), and then wait for the
user to type something and press
\keybackgroundcolor{gray}\keytextcolor{black}\widekey{RETURN}.\\

The optional prompt must be followed by a semicolon (;) and a variable or
comma-separated list of variables.  When there are multiple variables, the
{\ttfamily INPUT} statement will stop and wait for the user to type something
and hit \widekey{RETURN} for each one of the variables listed.  If no prompt is
given, then the semicolon (;) should not be used.\\

Example:\\

\codeblock{

	10 INPUT "PLEASE TYPE A NUMBER";A\\
	20 INPUT "AND YOUR NAME";A\$\\
	30 INPUT B\$\\
	40 PRINT "BET YOU DIDN'T KNOW WHAT I WANTED!"\\
	50 INPUT "TYPE 2 NUMBERS AND A STRING";A,B,C\$\\
	60 PRINT A,B,C\$\\

}


\subsection{INPUT\#}

The {\ttfamily INPUT\#} statement works just like the {\ttfamily INPUT}
statement, but takes the data from a previously opened file or device.  The
device number must be specified before the optional prompt or the variables.\\

\subsection{LET}

The {\ttfamily LET} statement is an optional statement used for assigning
variables in a BASIC program.  It is not necessary, but still exists as part of
the BASIC language for compatibility purposes.\\

Example:\\

\codeblock{
	10 LET A=5\\
	20 B=6\\
	30 PRINT A+B\\
	40 LET B=7\\
	50 PRINT A+B\\
}

The above code prints {\ttfamily 11} and {\ttfamily 12}, respectively, showing
that using {\ttfamily LET} on variable assignments is optional.

\subsection{LINE}

The {\ttfamily LINE} statement is used to draw a line in graphics mode.  The
{\ttfamily LINE} statement is passed the X and Y coordinates of the first
point, followed by the X and Y coordinates of the second point, followed by the
color of the line.  The {\ttfamily LINE} statement can only be used in graphics
mode, which must be set by calling the {\ttfamily SCREEN} statement with
{\ttfamily \$80}.\\

Examples:\\

Draw a red X across the screen.\\

\codeblock{
	10 SCREEN \$80\\
	20 LINE 0,0,319,239,2\\
	30 LINE 0,239,319,0,2\\
}

Draw a rainbow.\\

\codeblock{
	10 SCREEN \$80\\
	20 FOR I=0 TO 255\\
	30 LINE 159,0,I+32,239,I\\
	40 NEXT I\\
}

\subsection{LINPUT}

<TODO>

\subsection{LINPUT\#}

<TODO>

\subsection{LOCATE}

<TODO>

\subsection{MOUSE}

<TODO>

\subsection{MOVSPR}

<TODO>

\subsection{NEXT}

<TODO>

\subsection{ON}

<TODO>

\subsection{OPEN}

<TODO>

\subsection{POKE}

<TODO>

\subsection{POWEROFF}

<TODO>

\subsection{PRINT}

<TODO>

\subsection{PRINT\#}

<TODO>

\subsection{PSET}

<TODO>

\subsection{PSET}

<TODO>

\subsection{PSGCHORD}

The {\ttfamily PSGCHORD} statement instructs the programmable sound generator
to begin playing multiple notes at the same time.  For arguments, the
{\ttfamily PSGCHORD} statement accepts a channel and a string.  Because a chord
plays multiple notes at the same time, the channel argument specifies the
\emph{first} channel to use for the chord, but other channels will be used for
subsequent notes.  For example, if you specify a channel argument of {\ttfamily
3} for a chord which plays 4 notes, the {\ttfamily PSGCHORD} statement will
play the notes on channels 3, 4, 5, and 6.  It is important to set each of the
channels to use the desired waveform with the {\ttfamily PSGWAV} statement.
The string argument is used to specify which notes the {\ttfamily PSGCHORD}
statement will play.  For more information on specifying notes, see the chapter
on Sound.\\

Example:\\

\codeblock{

	REM PLAY A C MAJOR CHORD ON WITH A PULSE WAVEFORM\\
	10 PSGWAV 0,63:PSGWAV 1,63:PSGWAV 2,63\\
	20 PSGCHORD 0,"CGE"\\

}

\subsection{PSGFREQ}

<TODO>

\subsection{PSGINIT}

<TODO>

\subsection{PSGNOTE}

<TODO>

\subsection{PSGPAN}

<TODO>

\subsection{PSGPLAY}

<TODO>

\subsection{PSGVOL}

<TODO>

\subsection{PSGWAV}

<TODO>

\subsection{READ}

<TODO>

\subsection{RECT}

The {\ttfamily RECT} statement draws a filled rectangle in graphics mode in a
given color.  The first two arguments are the x and y coordinates for the upper
left corner of the rectangle.  The third and fourth arguments are the x and y
coordinates for the lower right corder of the rectangle.  The fifth argument is
a number from 0-255 that specifies the color from the current palette.\\

Example:\\

\codeblock{
	10 SCREEN \$80\\
	20 RECT 10,10,310,230,2\\
}

The {\ttfamily RECT} statement is similar to the {\ttfamily FRAME} statment,
except that {\ttfamily RECT} fills the rectangle with the specified color.

\subsection{REM}

<TODO>

\subsection{REN}

<TODO>

\subsection{RESTORE}

<TODO>

\subsection{RETURN}

<TODO>

\subsection{SCREEN}

<TODO>

\subsection{SLEEP}

<TODO>

\subsection{SPRITE}

<TODO>

\subsection{SPRMEM}

<TODO>

\subsection{STEP}

<TODO>

\subsection{STOP}

<TODO>

\subsection{SYS}

The {\ttfamily SYS} statement transfers control of the X16 to a machine
language program in memory.\\

Example:\\

\codeblock{
	SYS 8192\\
}

In the above example, the X16 will execute a machine language program stored at
address 8192 in decimal.  Because the Commander X16 also supports hexadecimal
arguments to BASIC statements, the same can be written as:\\

\codeblock{
	SYS \$2000\\
}

\subsection{THEN}

<TODO>

\subsection{TILE}

<TODO>

\subsection{TO}

<TODO>

\subsection{VPOKE}

<TODO>

\subsection{VLOAD}

<TODO>

\subsection{WAIT}

<TODO>

\section{Functions}

\subsection{ABS}

<TODO>

\subsection{ASC}

<TODO>

\subsection{ATN}

<TODO>

\subsection{BIN\$}

<TODO>

\subsection{CHR\$}

<TODO>

\subsection{COS}

<TODO>

\subsection{EXP}

<TODO>

\subsection{FN}

<TODO>

\subsection{FRE}

<TODO>

\subsection{HEX\$}

<TODO>

\subsection{INT}

<TODO>

\subsection{LEFT\$}

<TODO>

\subsection{LEN}

<TODO>

\subsection{LOG}

<TODO>

\subsection{MID\$}

<TODO>

\subsection{PEEK}

<TODO>

\subsection{\ttfamily Ï€}

<TODO>

\subsection{POINTER}

<TODO>

\subsection{POS}

<TODO>

\subsection{RIGHT\$}

<TODO>

\subsection{RND}

<TODO>

\subsection{RPT\$}

<TODO>

\subsection{RND}

<TODO>

\subsection{SGN}

<TODO>

\subsection{SIN}

<TODO>

\subsection{SPC}

<TODO>

\subsection{SQR}

<TODO>

\subsection{STR\$}

<TODO>

\subsection{STRPTR}

<TODO>

\subsection{TAB}

<TODO>

\subsection{TAN}

<TODO>

\subsection{USR}

<TODO>

\subsection{VAL}

<TODO>

\subsection{VPEEK}

<TODO>

